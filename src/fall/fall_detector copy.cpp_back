#include "fall_detector.h"
#include "../tracking/kalman_filter.h"
#include "../tracking/hungarian.h"
#include <cmath> // sqrt, abs
#include <algorithm> // min, max
#include <limits>
#include <chrono>
#include <iostream>
#include <fstream>
#include <sstream>
#include <deque>
#include <map>

#include <cstdio>
#include <sys/stat.h>
#include <sys/types.h>
#include <cstring>

#define ENABLE_PERF_PROFILING 1

using namespace std;

#if defined(__ARM_NEON) || defined(__ARM_NEON__)
#include <arm_neon.h>
#endif

namespace VisionSDK {

namespace {

// =========================================================
// Visualization Utilities (RGB)
// =========================================================

// Save RGB buffer (3 bytes per pixel) to BMP
bool saveBMP_RGB(const std::string& filename, const uint8_t* rgbData, int width, int height) {
    FILE* f = fopen(filename.c_str(), "wb");
    if (!f) return false;

    int filesize = 54 + 3 * width * height;
    uint8_t header[54] = {
        0x42, 0x4D, 0,0,0,0, 0,0,0,0, 54,0,0,0, 40,0,0,0,
        0,0,0,0, 0,0,0,0, 1,0, 24,0, 0,0,0,0, 0,0,0,0, 0,0,0,0, 0,0,0,0
    };

    header[2] = (uint8_t)(filesize);
    header[3] = (uint8_t)(filesize >> 8);
    header[4] = (uint8_t)(filesize >> 16);
    header[5] = (uint8_t)(filesize >> 24);
    header[18] = (uint8_t)(width);
    header[19] = (uint8_t)(width >> 8);
    header[20] = (uint8_t)(width >> 16);
    header[21] = (uint8_t)(width >> 24);
    header[22] = (uint8_t)(height);
    header[23] = (uint8_t)(height >> 8);
    header[24] = (uint8_t)(height >> 16);
    header[25] = (uint8_t)(height >> 24);

    fwrite(header, 1, 54, f);

    int padSize = (4 - (width * 3) % 4) % 4;
    uint8_t pad[3] = {0, 0, 0};

    // BMP is stored bottom-to-top, BGR format
    for (int y = height - 1; y >= 0; --y) {
        for (int x = 0; x < width; ++x) {
            int idx = (y * width + x) * 3;
            uint8_t r = rgbData[idx];
            uint8_t g = rgbData[idx + 1];
            uint8_t b = rgbData[idx + 2];
            uint8_t bgr[3] = {b, g, r}; // Swap for BMP
            fwrite(bgr, 1, 3, f);
        }
        fwrite(pad, 1, padSize, f);
    }
    fclose(f);
    return true;
}

void drawPixelRGB(std::vector<uint8_t>& img, int w, int h, int x, int y, uint8_t r, uint8_t g, uint8_t b) {
    if (x >= 0 && x < w && y >= 0 && y < h) {
        int idx = (y * w + x) * 3;
        img[idx] = r;
        img[idx + 1] = g;
        img[idx + 2] = b;
    }
}

void drawLineRGB(std::vector<uint8_t>& img, int w, int h, int x1, int y1, int x2, int y2, uint8_t r, uint8_t g, uint8_t b, int thickness = 1) {
    int dx = std::abs(x2 - x1), sx = x1 < x2 ? 1 : -1;
    int dy = -std::abs(y2 - y1), sy = y1 < y2 ? 1 : -1;
    int err = dx + dy, e2; 
    
    // Helper to draw brush
    auto drawBrush = [&](int cx, int cy) {
        for (int ty = -thickness/2; ty <= thickness/2; ty++) {
            for (int tx = -thickness/2; tx <= thickness/2; tx++) {
                drawPixelRGB(img, w, h, cx + tx, cy + ty, r, g, b);
            }
        }
    };

    while (true) {
        drawBrush(x1, y1);
        if (x1 == x2 && y1 == y2) break;
        e2 = 2 * err;
        if (e2 >= dy) { err += dy; x1 += sx; }
        if (e2 <= dx) { err += dx; y1 += sy; }
    }
}

void drawRectRGB(std::vector<uint8_t>& img, int w, int h, int x, int y, int rw, int rh, uint8_t r, uint8_t g, uint8_t b, int thickness = 2) {
    int x2 = x + rw - 1;
    int y2 = y + rh - 1;
    drawLineRGB(img, w, h, x, y, x2, y, r, g, b, thickness);
    drawLineRGB(img, w, h, x2, y, x2, y2, r, g, b, thickness);
    drawLineRGB(img, w, h, x2, y2, x, y2, r, g, b, thickness);
    drawLineRGB(img, w, h, x, y2, x, y, r, g, b, thickness);
}

void drawFilledRectRGB(std::vector<uint8_t>& img, int w, int h, int x, int y, int rw, int rh, uint8_t r, uint8_t g, uint8_t b) {
    for (int j = y; j < y + rh; j++) {
        for (int i = x; i < x + rw; i++) {
            drawPixelRGB(img, w, h, i, j, r, g, b);
        }
    }
}

void drawArrowRGB(std::vector<uint8_t>& img, int w, int h, int x, int y, int dx, int dy, uint8_t r, uint8_t g, uint8_t b, int thickness = 2) {
    int x2 = x + dx;
    int y2 = y + dy;
    drawLineRGB(img, w, h, x, y, x2, y2, r, g, b, thickness);
    
    // Draw Arrow Head
    // Simple 30 degree wings
    if (std::abs(dx) + std::abs(dy) > 5) {
        float angle = atan2((float)dy, (float)dx);
        float headLen = 15.0f; // Longer head
        float angle1 = angle + M_PI * 0.85; // Backwards angle
        float angle2 = angle - M_PI * 0.85;

        int x3 = x2 + (int)(cos(angle1) * headLen);
        int y3 = y2 + (int)(sin(angle1) * headLen);
        int x4 = x2 + (int)(cos(angle2) * headLen);
        int y4 = y2 + (int)(sin(angle2) * headLen);

        drawLineRGB(img, w, h, x2, y2, x3, y3, r, g, b, thickness);
        drawLineRGB(img, w, h, x2, y2, x4, y4, r, g, b, thickness);
    }
}

// Minimal 5x7 bitmap font
const uint8_t font5x7[] = {
    // 0-9
    0x1F,0x11,0x1F, 0x00,0x1F,0x00, 0x1D,0x15,0x17, 0x15,0x15,0x1F, 0x07,0x04,0x1F,
    0x17,0x15,0x1D, 0x1F,0x15,0x1D, 0x01,0x01,0x1F, 0x1F,0x15,0x1F, 0x17,0x15,0x1F,
    // .
    0x10,0x00,0x00,
    // F (11)
    0x1F,0x05,0x00,
    // A (12)
    0x1F,0x05,0x1F, 
    // L (13)
    0x1F,0x10,0x10,
    // T (14)
    0x01,0x1F,0x01,
    // R (15)
    0x1F,0x05,0x1A,
    // U (16)
    0x1F,0x10,0x1F,
    // E (17)
    0x1F,0x15,0x11,
    // S (18)
    0x1D,0x15,0x17,
     // M (19)
    0x1F,0x02,0x1F,
    // I (20)
    0x00,0x1F,0x00,
    // B (21)
    0x1F,0x15,0x0A,
    // D (22)
    0x1F,0x11,0x0E,
    // X (23)
    0x11,0x04,0x11
};

void drawCharRGB(std::vector<uint8_t>& img, int w, int h, int cx, int cy, int charArgs, uint8_t r, uint8_t g, uint8_t b, int scale = 1) {
    if (charArgs < 0 || charArgs > 23) return;
    const uint8_t* ptr = font5x7 + charArgs * 3;
    for (int col = 0; col < 3; col++) {
        uint8_t colData = ptr[col];
        for (int row = 0; row < 5; row++) {
            if ((colData >> row) & 1) { 
                // Draw Scaled Pixel
                for (int sy = 0; sy < scale; sy++) {
                    for (int sx = 0; sx < scale; sx++) {
                        int px = cx + (col * 2) * scale + sx;
                        int py = cy + (row * 2) * scale + sy;
                         drawPixelRGB(img, w, h, px, py, r, g, b);
                    }
                }
            }
        }
    }
}

void drawStringRGB(std::vector<uint8_t>& img, int w, int h, int x, int y, const std::string& s, uint8_t r, uint8_t g, uint8_t b, int scale = 1) {
    int cx = x;
    for (char c : s) {
        int idx = -1;
        if (c >= '0' && c <= '9') idx = c - '0';
        else if (c == '.') idx = 10;
        else if (c == 'F') idx = 11;
        else if (c == 'A') idx = 12;
        else if (c == 'L') idx = 13;
        else if (c == 'T') idx = 14;
        else if (c == 'R') idx = 15;
        else if (c == 'U') idx = 16;
        else if (c == 'E') idx = 17;
        else if (c == 'S') idx = 18;
        else if (c == 'M') idx = 19;
        else if (c == 'I') idx = 20;
        else if (c == 'B') idx = 21;
        else if (c == 'D') idx = 22;
        else if (c == 'X') idx = 23;
        
        if (idx != -1) {
            drawCharRGB(img, w, h, cx, y, idx, r, g, b, scale);
            cx += 8 * scale; 
        } else {
             cx += 4 * scale; 
        }
    }
}

void drawFloatRGB(std::vector<uint8_t>& img, int w, int h, int x, int y, float v, uint8_t r, uint8_t g, uint8_t b, int scale = 1) {
    char buf[16];
    sprintf(buf, "%.1f", v);
    drawStringRGB(img, w, h, x, y, buf, r, g, b, scale);
}

} // anonymous namespace

// ==================================================================================
//  Helpers & Profiler (from C_V2_EDGE.cpp)
// ==================================================================================

struct FunctionTimer {
    std::map<std::string, double> total_ms;
    std::map<std::string, uint64_t> calls;

    inline void add(const std::string& name, double ms) {
        total_ms[name] += ms;
        calls[name] += 1ULL;
    }
};

struct TimerGuard {
    FunctionTimer* prof;
    std::string name;
    std::chrono::high_resolution_clock::time_point t0;
    TimerGuard(FunctionTimer& p, const std::string& n) : prof(&p), name(n), t0(std::chrono::high_resolution_clock::now()) {}
    ~TimerGuard() {
        auto t1 = std::chrono::high_resolution_clock::now();
        double ms = std::chrono::duration_cast<std::chrono::microseconds>(t1 - t0).count() / 1000.0;
        prof->add(name, ms);
    }
};

// ==================================================================================
//  OptimizedBlockMotionEstimator (from C_V2_EDGE.cpp)
// ==================================================================================

class OptimizedBlockMotionEstimator {
public:
    OptimizedBlockMotionEstimator(int h_blocks, int v_blocks, int block_sz, int sr)
    : horizontal_blocks(h_blocks), vertical_blocks(v_blocks),
      block_size(block_sz), search_range(sr), diff_check_range(5) 
    {
        block_active_counters.assign(h_blocks * v_blocks, 0);
    }

    void setDiffCheckRange(int n) { diff_check_range = n; }
    void setSearchMode(int mode) { search_algo_mode = mode; }
    void setBlockDecay(bool enable, int frames) { 
        enable_block_decay = enable; 
        block_decay_max_frames = frames; 
        printf("DEBUG: setBlockDecay enable=%d frames=%d\n", enable, frames);
    }

    void setBlockDilation(bool enable) {
        enable_block_dilation = enable;
    }

    void blockBasedMotionEstimation(const ::Image& curr_frame_in,
                                    std::vector<MotionVector>& motion_vectors,
                                    std::vector<BlockPosition>& positions,            
                                    std::vector<bool>& changed_blocks_mask,
                                    std::vector<::Image>& active_blocks,
                                    std::vector<int>& active_indices,
                                    int dilation_threshold = 2)
    {
        // TimerGuard total_t(profiler, "blockBasedMotionEstimation_total");

        motion_vectors.clear();
        positions.clear();
        changed_blocks_mask.clear();
        active_blocks.clear();
        active_indices.clear();

        const int total_blocks = horizontal_blocks * vertical_blocks;
        
        if (prev_frames.empty()) 
        {
            buildPositionsOnce(curr_frame_in, positions_cache);
            positions.assign(positions_cache.begin(), positions_cache.end());
            motion_vectors.assign(total_blocks, MotionVector(0, 0));
            changed_blocks_mask.assign(total_blocks, false);
            prev_frames.push_back(curr_frame_in.clone());
            return;
        }

        const ::Image& prev_frame_ref = prev_frames.back(); // For motion estimation (t-1)

        const ::Image& curr_frame = curr_frame_in;

        if ((int)positions_cache.size() != total_blocks) {
             buildPositionsOnce(curr_frame, positions_cache);
        }
        positions = positions_cache;

        // --- Change Detection ---
        // --- Change Detection ---
        changed_blocks_mask.assign(total_blocks, false);
        detectChangedBlocks(prev_frames, curr_frame, changed_blocks_mask, 0.05, dilation_threshold);

        // --- Block Decay Logic ---
        if (enable_block_decay) {
            // printf("DEBUG: Applying Block Decay...\n");
            if ((int)block_active_counters.size() != total_blocks) {
                block_active_counters.assign(total_blocks, 0);
            }

            for (int i = 0; i < total_blocks; ++i) {
                if (changed_blocks_mask[i]) {
                    // Reset counter if block is naturally active
                    block_active_counters[i] = block_decay_max_frames;
                } else if (block_active_counters[i] > 0) {
                    // Decrease counter and FORCE active
                    block_active_counters[i]--;
                    changed_blocks_mask[i] = true;
                }
            }
        }

        // --- ROI Creation & Motion Estimation ---
        // Zero-copy: Avoid creating 'active_blocks' which are deep copies.
        // Instead, we just iterate indices and pass pointers.
        
        // divideActiveBlocks logic is simple: if changed_mask[i] is true, it's active.
        // We can just iterate directly.
        motion_vectors.assign(total_blocks, MotionVector(0, 0));

        const uint8_t* curr_data = curr_frame.getData();
        int curr_stride = curr_frame.width();

        for (int i = 0; i < total_blocks; ++i) {
             if (!changed_blocks_mask[i]) continue;
             
             const BlockPosition& pos = positions_cache[i];
             int bw = pos.x_end - pos.x_start;
             int bh = pos.y_end - pos.y_start;
             
             // Point to ROI in current frame
             const uint8_t* block_ptr = curr_data + pos.y_start * curr_stride + pos.x_start;

             int dx = 0, dy = 0, sad = 0;
             optimizedMotionEstimation(block_ptr, curr_stride, prev_frame_ref,
                                       pos.x_start, pos.y_start,
                                       bh, bw, dx, dy, sad, i);

             motion_vectors[i] = MotionVector(dx, dy);
        }

        updateMotionHistoryFast(motion_vectors);
        prev_frames.push_back(curr_frame.clone());
        if((int)prev_frames.size() > diff_check_range) prev_frames.pop_front();
    }

    FunctionTimer profiler;

    void PrintTimings() {
         std::cout << "\n=== AVG TIMINGS ===\n";
         for(auto& kv : profiler.total_ms) {
             std::cout << kv.first << ": " << kv.second << " ms\n";
         }
    }

private:
    int horizontal_blocks;
    int vertical_blocks;
    int block_size;
    int search_range;
    int diff_check_range;
    int search_algo_mode = 1; // Default to LDSP

    std::deque<::Image> prev_frames;
    std::vector<BlockPosition> positions_cache;
    std::vector<std::vector<MotionVector>> motion_history;
    
    // Block Decay Logic
    std::vector<int> block_active_counters;
    bool enable_block_decay = false;
    int block_decay_max_frames = 0;

    // Block Dilation Logic
    bool enable_block_dilation = false;

    void buildPositionsOnce(const ::Image& img, std::vector<BlockPosition>& out) {
        out.clear();
        int h = img.height(), w = img.width();
        int bh = h / vertical_blocks;
        int bw = w / horizontal_blocks;

        out.reserve(horizontal_blocks * vertical_blocks);
        for (int by = 0; by < vertical_blocks; ++by) {
            for (int bx = 0; bx < horizontal_blocks; ++bx) {
                int xs = bx * bw;
                int ys = by * bh;
                int xe = (bx == horizontal_blocks - 1) ? w : xs + bw;
                int ye = (by == vertical_blocks - 1) ? h : ys + bh;
                BlockPosition p; 
                p.x_start = xs; p.x_end = xe; 
                p.y_start = ys; p.y_end = ye;
                p.i=by; p.j=bx;
                out.push_back(p);
            }
        }
    }

    // NEON optimized SAD row
    static inline int sad_u8_row(const uint8_t* a, const uint8_t* b, int len) {
#if defined(__ARM_NEON) || defined(__ARM_NEON__)
        int sad = 0;
        int n = len;
        while (n >= 16) {
            uint8x16_t va = vld1q_u8(a);
            uint8x16_t vb = vld1q_u8(b);
            uint8x16_t vdiff = vabdq_u8(va, vb);
            uint16x8_t vpad1 = vpaddlq_u8(vdiff);
            uint32x4_t vpad2 = vpaddlq_u16(vpad1);
            uint64x2_t vpad3 = vpaddlq_u32(vpad2);
            sad += (int)vgetq_lane_u64(vpad3, 0);
            sad += (int)vgetq_lane_u64(vpad3, 1);
            a += 16; b += 16; n -= 16;
        }
        while (n--) sad += std::abs((int)(*a++) - (int)(*b++));
        return sad;
#else
        int sad = 0;
        for (int i=0;i<len;++i) sad += std::abs((int)a[i] - (int)b[i]);
        return sad;
#endif
    }

    int computeSAD(const uint8_t* block_data, int block_stride, int bw, int bh, const ::Image& prev_frame, int ref_x, int ref_y) {
        const int stride_prev = prev_frame.width();
        const uint8_t* pprev  = prev_frame.getData() + ref_y * stride_prev + ref_x;

        int sad = 0;
        for (int y=0; y<bh; ++y) {
            sad += sad_u8_row(block_data + y * block_stride, pprev + y * stride_prev, bw);
        }
        return sad;
    }


    // Optimized NEON Change Ratio Calculation (Fuses binarize + count)
    double computeChangeRatio(const ::Image& prev, const ::Image& curr, const BlockPosition& pos, int threshold = 30) {
        const uint8_t* pprev = prev.getData();
        const uint8_t* pcurr = curr.getData();
        const int stride = prev.width();
        int count = 0;
        int roi_w = pos.x_end - pos.x_start;
        int roi_h = pos.y_end - pos.y_start;
        
        const uint8_t* r_prev = pprev + pos.y_start * stride + pos.x_start;
        const uint8_t* r_curr = pcurr + pos.y_start * stride + pos.x_start;

#if defined(__ARM_NEON) || defined(__ARM_NEON__)
        const uint8x16_t vthr = vdupq_n_u8((uint8_t)threshold);
        for(int y=0; y<roi_h; ++y) {
            int x = 0;
            const uint8_t* rp = r_prev + y * stride;
            const uint8_t* rc = r_curr + y * stride;
            
            // Vectorized loop
            for (; x <= roi_w - 16; x += 16) {
                uint8x16_t va = vld1q_u8(rp + x);
                uint8x16_t vb = vld1q_u8(rc + x);
                uint8x16_t vdiff = vabdq_u8(va, vb);
                uint8x16_t vmask = vcgtq_u8(vdiff, vthr);
                // Count bits in vmask? 
                // vmask has 0xFF for set, 0x00 for unset.
                // Population count is expensive in NEON v7 without special instruction.
                // Alternative: accumulate mask values? 0xFF = -1 in int8.
                // Let's use simple check: if vmask is all zero, skip.
                // Or just spill to stack? No.
                // Accumulate to count:
                // cnt += population_count(vmask).
                // Efficient way:
                // vcntq_u8 counts bits. 0xFF has 8 bits. We want bytes.
                // simple: shift right and add?
                // Actually, vcnt is available in AArch64 or newer.
                // Cortex-A7 supports vcnt? Yes (NEON VFPv4).
                uint8x16_t vones = vcntq_u8(vmask); // Each byte becomes 8 (for 0xFF) or 0.
                // Sum bytes.
                // Pairwise add chain.
                uint16x8_t vp = vpaddlq_u8(vones);
                uint32x4_t vp2 = vpaddlq_u16(vp);
                uint64x2_t vp3 = vpaddlq_u32(vp2);
                uint64_t sum = vgetq_lane_u64(vp3, 0) + vgetq_lane_u64(vp3, 1);
                count += (int)(sum / 8); 
            }
            // Scalar tail
            for (; x < roi_w; ++x) {
                if (std::abs((int)rp[x] - (int)rc[x]) > threshold) count++;
            }
        }
#else
        for(int y=0; y<roi_h; ++y) {
            const uint8_t* rp = r_prev + y * stride;
            const uint8_t* rc = r_curr + y * stride;
            for(int x=0; x<roi_w; ++x) {
                if (std::abs((int)rp[x] - (int)rc[x]) > threshold) count++;
            }
        }
#endif
        return (double)count / (roi_w * roi_h);
    }

    int detectChangedBlocks(const std::deque<::Image>& history, const ::Image& curr,
                            std::vector<bool>& changed_blocks_mask,
                            double threshold_ratio,
                            int dilation_threshold = 2)
    {
        int total_changed = 0;
        
        // Loop through recent history to find ANY change
        // We iterate positions first to potentially break early? 
        // No, current logic is "OR" across history frames.
        // If a block changed in ANY frame, it's changed.
        
        // Cache optimization: Swap loops?
        // If we iterate history inside, we read image multiple times.
        // History is small (5 frames).
        // Positions are many (12x16 = 192).
        // Iterating blocks efficiently is key.
        // Current logic: For each history frame, create diff, check all blocks.
        // Optimized logic: For each block, check history frames until change found.
        
        for(size_t i=0; i<positions_cache.size(); ++i) {
             if (changed_blocks_mask[i]) continue; // Already marked changed

             const auto& pos = positions_cache[i];
             
             // Check against history
             for (const auto& past_frame : history) {
                 double ratio = computeChangeRatio(past_frame, curr, pos, 30);
                 if(ratio > threshold_ratio) {
                     changed_blocks_mask[i] = true;
                     total_changed++;
                     break; // Found change, move to next block
                 }
             }
        }

        // Post-Processing: Hole Filling (Dilation) at Block Level
        // If a block is unchanged but has >= 2 changed neighbors, mark it changed.
        if (enable_block_dilation) {
            std::vector<bool> dilation_mask = changed_blocks_mask;
            int added_by_dilation = 0;
            
            for (int by = 0; by < vertical_blocks; ++by) {
                for (int bx = 0; bx < horizontal_blocks; ++bx) {
                    int idx = by * horizontal_blocks + bx;
                    if (changed_blocks_mask[idx]) continue;

                    int neighbors = 0;
                    if (bx > 0 && changed_blocks_mask[idx - 1]) neighbors++; // Left
                    if (bx < horizontal_blocks - 1 && changed_blocks_mask[idx + 1]) neighbors++; // Right
                    if (by > 0 && changed_blocks_mask[idx - horizontal_blocks]) neighbors++; // Up
                    if (by < vertical_blocks - 1 && changed_blocks_mask[idx + horizontal_blocks]) neighbors++; // Down
                    
                    if (neighbors >= dilation_threshold) {
                        dilation_mask[idx] = true;
                        added_by_dilation++;
                    }
                }
            }
            
            if (added_by_dilation > 0) {
                changed_blocks_mask = dilation_mask;
                total_changed += added_by_dilation;
            }
        }

        return total_changed;
    }


    void predictMotionVectorFast(int block_idx, int& pdx, int& pdy) {
        if(!motion_history.empty() && block_idx < (int)motion_history.back().size()) {
             pdx = motion_history.back()[block_idx].dx;
             pdy = motion_history.back()[block_idx].dy;
        } else {
             pdx = 0; pdy = 0;
        }
    }

    void updateMotionHistoryFast(const std::vector<MotionVector>& mvs) {
        motion_history.push_back(mvs);
        if(motion_history.size() > 5) motion_history.erase(motion_history.begin());
    }

    void optimizedMotionEstimation(const uint8_t* block_data, int block_stride, const ::Image& prev,
                                   int x_start, int y_start, int bh, int bw,
                                   int& best_dx, int& best_dy, int& best_sad, int idx)
    {
        int pdx=0, pdy=0;
        predictMotionVectorFast(idx, pdx, pdy);
        if (search_algo_mode == 0) {
            fastDiamondSearch(block_data, block_stride, prev, x_start, y_start, bh, bw, pdx, pdy, best_dx, best_dy, best_sad);
        } else {
            LDSP_SDSP_Search(block_data, block_stride, prev, x_start, y_start, bh, bw, pdx, pdy, best_dx, best_dy, best_sad);
        }
    }

    void fastDiamondSearch(const uint8_t* block_data, int block_stride, const ::Image& prev,
                           int x_start, int y_start, int bh, int bw,
                           int init_dx, int init_dy,
                           int& best_dx, int& best_dy, int& best_sad)
    {
        best_dx = init_dx; best_dy = init_dy;
        
        auto safe_in = [&](int rx, int ry) {
            return (rx>=0 && ry>=0 && rx+bw<=prev.width() && ry+bh<=prev.height());
        };

        best_sad = std::numeric_limits<int>::max();
        if(safe_in(x_start+best_dx, y_start+best_dy)) {
             best_sad = computeSAD(block_data, block_stride, bw, bh, prev, x_start+best_dx, y_start+best_dy);
        }

        static const int small_diamond[5][2] = { {0,0},{-1,0},{1,0},{0,-1},{0,1} };
        bool improved = true;
        int iter = 0;
        while(improved && iter < 3) {
            improved = false;
            int cur_dx = best_dx, cur_dy = best_dy;
            for(int k=0; k<5; ++k) {
                int cdx = cur_dx + small_diamond[k][0];
                int cdy = cur_dy + small_diamond[k][1];
                if(std::abs(cdx) > search_range || std::abs(cdy) > search_range) continue;
                int rx = x_start + cdx;
                int ry = y_start + cdy;
                if(!safe_in(rx, ry)) continue;
                
                int sad = computeSAD(block_data, block_stride, bw, bh, prev, rx, ry);
                if(sad < best_sad) {
                    best_sad = sad; best_dx = cdx; best_dy = cdy;
                    improved = true;
                }
            }
            iter++;
        }
    }
    void LDSP_SDSP_Search(const uint8_t* block_data, int block_stride, const ::Image& prev_frame,
        int x_start, int y_start, int block_h, int block_w,
        int predicted_dx, int predicted_dy,
        int& best_dx, int& best_dy, int& best_sad) {

        // --- 1. 初始化 ---
        // 先計算起始預測點 (Center) 的 SAD，作為比較的基準
        best_dx = predicted_dx;
        best_dy = predicted_dy;
        best_sad = std::numeric_limits<int>::max();

        auto safe_in = [&](int rx, int ry) {
            return (rx>=0 && ry>=0 && rx+block_w<=prev_frame.width() && ry+block_h<=prev_frame.height());
        };

        // 初始位置邊界檢查與 SAD 計算 (Center Point)
        {
            int ref_x = x_start + best_dx;
            int ref_y = y_start + best_dy;

            // 確保預測點本身沒有出界
            if (abs(best_dx) <= search_range && abs(best_dy) <= search_range && safe_in(ref_x, ref_y)) {
                best_sad = computeSAD(block_data, block_stride, block_w, block_h, prev_frame, ref_x, ref_y);
            }
        }

        // 定義 LDSP (大鑽石) 的 8 個周圍點 (不含中心，半徑=2)
        const int ldsp_offsets[][2] = {
            {0, -2}, {1, -1}, {2, 0}, {1, 1},
            {0, 2}, {-1, 1}, {-2, 0}, {-1, -1}
        };
        const int ldsp_count = 8;

        // 定義 SDSP (小鑽石) 的 4 個周圍點 (不含中心，半徑=1)
        const int sdsp_offsets[][2] = {
            {0, -1}, {1, 0}, {0, 1}, {-1, 0}
        };
        const int sdsp_count = 4;

        // --- 2. 階段一：LDSP (Large Diamond Search Pattern) ---
        int search_iterations = 0;
        const int max_iterations = 10;
        bool center_is_best = false;

        while (!center_is_best && search_iterations < max_iterations) {
            center_is_best = true;

            int next_center_dx = best_dx;
            int next_center_dy = best_dy;
            int local_min_sad = best_sad;

            for (int k = 0; k < ldsp_count; k++) {
                int candidate_dx = best_dx + ldsp_offsets[k][0];
                int candidate_dy = best_dy + ldsp_offsets[k][1];

                if (abs(candidate_dx) > search_range || abs(candidate_dy) > search_range)
                    continue;

                int ref_x = x_start + candidate_dx;
                int ref_y = y_start + candidate_dy;

                if (!safe_in(ref_x, ref_y))
                    continue;

                int sad = computeSAD(block_data, block_stride, block_w, block_h, prev_frame, ref_x, ref_y);

                if (sad < local_min_sad) {
                    local_min_sad = sad;
                    next_center_dx = candidate_dx;
                    next_center_dy = candidate_dy;
                    center_is_best = false; 
                }
            }

            if (!center_is_best) {
                best_dx = next_center_dx;
                best_dy = next_center_dy;
                best_sad = local_min_sad;
            }
            search_iterations++;
        }

        // --- 3. 階段二：SDSP (Small Diamond Search Pattern) ---
        for (int k = 0; k < sdsp_count; k++) {
            int candidate_dx = best_dx + sdsp_offsets[k][0];
            int candidate_dy = best_dy + sdsp_offsets[k][1];

            if (abs(candidate_dx) > search_range || abs(candidate_dy) > search_range)
                continue;

            int ref_x = x_start + candidate_dx;
            int ref_y = y_start + candidate_dy;

            if (!safe_in(ref_x, ref_y))
                continue;

            int sad = computeSAD(block_data, block_stride, block_w, block_h, prev_frame, ref_x, ref_y);

            if (sad < best_sad) {
                best_sad = sad;
                best_dx = candidate_dx;
                best_dy = candidate_dy;
            }
        }
    }
};

// ==================================================================================
//  Object Detection Logic (from C_V2.cpp)
// ==================================================================================

std::vector<MotionObject> extractMotionObjects(
    const std::vector<MotionVector>& blocks,
    const std::vector<bool>& changed_mask,
    int rows, int cols,
    float threshold,
    int searchRadius)
{
    std::vector<MotionObject> objs;
    std::vector<char> visited(rows * cols, 0);

    auto idx = [&](int r, int c) { return r * cols + c; };
    int objId = 0;

    for (int r = 0; r < rows; r++) {
        for (int c = 0; c < cols; c++) {
            int start = idx(r, c);
            if(start >= (int)blocks.size()) continue;

            float mag = std::sqrt((float)blocks[start].dx * blocks[start].dx +
                                  (float)blocks[start].dy * blocks[start].dy);

            // CHANGED: Allow if Magnitude High OR in Changed Mask (Dilation)
            bool is_changed = false;
            if (start < (int)changed_mask.size()) is_changed = changed_mask[start];
            
            if (mag < threshold && !is_changed) continue;
            if (visited[start]) continue;

            MotionObject obj;
            obj.id = objId++;

            std::vector<int> stack = { start };
            visited[start] = 1;

            float sumDx = 0, sumDy = 0;
            int count = 0;
            int motion_count = 0; // NEW: Count only blocks with motion
            int sumR = 0, sumC = 0;

            while (!stack.empty()) {
                int cur = stack.back(); stack.pop_back();

                int cr = cur / cols;
                int cc = cur % cols;

                obj.blocks.push_back(cur);
                
                // Track geometric stats (all blocks)
                sumR += cr;
                sumC += cc;
                count++;
                
                // Track motion stats (only significant blocks)
                if (std::abs(blocks[cur].dx) > 0.1f || std::abs(blocks[cur].dy) > 0.1f) {
                    sumDx += blocks[cur].dx;
                    sumDy += blocks[cur].dy;
                    motion_count++;
                }
                
                // Dynamic Search Radius
                for (int dy = -searchRadius; dy <= searchRadius; dy++) {
                    for (int dx = -searchRadius; dx <= searchRadius; dx++) {
                        if (dy == 0 && dx == 0) continue;

                        int nr = cr + dy, nc = cc + dx;
                        if (nr < 0 || nr >= rows || nc < 0 || nc >= cols) continue;
                        
                        int ni = idx(nr, nc);
                        if(ni >= (int)visited.size()) continue; 
                        if (visited[ni]) continue;

                        float mag2 = std::sqrt((float)blocks[ni].dx * blocks[ni].dx +
                                             (float)blocks[ni].dy * blocks[ni].dy);
                        
                        bool is_changed2 = false;
                        if (ni < (int)changed_mask.size()) is_changed2 = changed_mask[ni];

                        if (mag2 < threshold && !is_changed2) continue;

                        visited[ni] = 1;
                        stack.push_back(ni);
                    }
                }
            }

            if(count > 0) {
                // Motion Average: Based on motion blocks only (avoid dilution by static blocks)
                if (motion_count > 0) {
                    obj.avgDx = sumDx / motion_count;
                    obj.avgDy = sumDy / motion_count;
                } else {
                    obj.avgDx = 0;
                    obj.avgDy = 0;
                }
                
                // Geometric Center: Based on ALL blocks (ROI)
                obj.centerX = sumC / (float)count;
                obj.centerY = sumR / (float)count;
                
                obj.strength = std::sqrt(obj.avgDx * obj.avgDx + obj.avgDy * obj.avgDy);
                obj.safe_area_ratio = 0.0f; // Calculated later
                objs.push_back(obj);
            }
        }
    }
    return objs;
}

// Helper to check point in polygon
inline float cross_product(float ax, float ay, float bx, float by, float cx, float cy) {
    return (bx - ax) * (cy - ay) - (by - ay) * (cx - ax);
}

// Check if point p is inside convex quad defined by poly
bool isPointInConvexQuad(const std::vector<std::pair<float, float>>& poly, float px, float py) {
    if (poly.size() != 4) return false;
    bool has_pos = false, has_neg = false;
    for (int i = 0; i < 4; i++) {
        float cp = cross_product(poly[i].first, poly[i].second, 
                                 poly[(i+1)%4].first, poly[(i+1)%4].second, 
                                 px, py);
        if (cp > 0) has_pos = true;
        if (cp < 0) has_neg = true;
        if (has_pos && has_neg) return false;
    }
    return true;
}

void detectObjectTemporalMotion(
    const std::vector<std::vector<MotionObject>>& history,
    float movementThreshold,
    float strongThreshold,
    float accelerationThreshold,
    float safeAreaThreshold,
    int M, int N,
    float accelUpperThreshold,
    float accelLowerThreshold,
    const std::vector<std::pair<int, int>>& bed_region,
    std::vector<int>& outTriggeredIds,
    long long currentFrameIdx,
    std::string& outWarning,
    int frame_width, int frame_height,
    int grid_cols, int grid_rows,
    bool enable_bed_exit_verification, // NEW
    bool enable_block_shrink_verification // NEW
    )
{
    if (!enable_block_shrink_verification || !enable_bed_exit_verification)
    {
        //printf("[FallDetector] Block Shrink Verification and Bed Exit Verification are disabled.\n");
    }
    int T = (int)history.size();
    if (T < N) return;
    int start = (T > M) ? (T - M) : 0;

    // Pre-process Bed Region Poly (float) for efficiency
    std::vector<std::pair<float, float>> bed_poly;
    bool has_bed_poly = false;
    if (bed_region.size() == 4) {
        for(auto& p : bed_region) bed_poly.push_back({(float)p.first, (float)p.second});
        has_bed_poly = true;
        //printf("has_bed_poly = True\n");
    }

    // Track how many times each object triggers a "Fall Signal" in the window
    std::map<int, int> object_signal_counts;

    // =================================================================================
    // STEP 1: Traverse Window to Count Fall Signals (N-out-of-M)
    // =================================================================================
    for (int f = start; f < T; f++) 
    {
        long long actual_frame_num = currentFrameIdx - (T - 1 - f);
        for (const auto& obj : history[f]) 
        {
            if (f == (T-1))
            {
                printf("[Debug] actual_frame_num %d, obj.id %d, obj.strength %f \n", actual_frame_num, obj.id, obj.strength);
            }
            // Basic Conditions
            bool is_strong_fall = (obj.strength >= strongThreshold && obj.blocks.size() > 0);
            bool is_accel_fall = (obj.acceleration > accelerationThreshold);
            bool is_larger_safe_area = (obj.safe_area_ratio > safeAreaThreshold);
            
            // Accel Change
            bool is_accel_change_fall = false;
            float prev_accel = 0.0f;
            if (f > 0) {
                 for(const auto& prev : history[f-1]) {
                     if(prev.id == obj.id) {
                         if (prev.acceleration > accelUpperThreshold && obj.acceleration < accelLowerThreshold) 
                             is_accel_change_fall = true;
                         break;
                     }
                 }
            }

            // PRIMARY TRIGGER: Any strong momentum or acceleration event
            bool is_primary_signal = false;
            
            // We maintain the filter that the fall must be valid (Vertical Velocity > 1.5, Outside Safe Area)
            // But we allow "Bed Exit" which transitions from Safe->Unsafe.
            // Let's stick to the core requirement: 
            // "Is there N frames of FALL EVIDENCE?"
            // Evidence = (Strong || HighAccel || AccelChange) AND (VerticalVelocity > 1.5)
            
            // Note: obj.avgDy is the vertical velocity. Defaults checking > 1.5
            // if (obj.avgDy > 1.5f) { // Re-enabled filter
            
            if (!is_larger_safe_area || is_strong_fall) { // Allow Strong Fall even if seemingly safely inside? Or NO?
                 // Usually falls happen outside.
                 if (!is_larger_safe_area) {
                     if (is_strong_fall || is_accel_fall || is_accel_change_fall) 
                     {
                        //printf("frame id %d, obj.strength %f, obj.acceleration %f, obj.avgDy %f\n", actual_frame_num, obj.strength, obj.acceleration, obj.avgDy);
                        is_primary_signal = true;
                     }
                 }
            }
            //}

            if (is_primary_signal) {
                object_signal_counts[obj.id]++;
                // printf("DEBUG: Frame %lld Obj %d Signal Count %d\n", actual_frame_num, obj.id, object_signal_counts[obj.id]);
            }
        }
    }

    // =================================================================================
    // STEP 2: Secondary Verification (History Check) for Candidates with Count >= N
    // =================================================================================
    for (auto const& [id, count] : object_signal_counts) 
    {
        if (count >= N) 
        {
            if (!enable_block_shrink_verification || !enable_bed_exit_verification) 
            {
                outTriggeredIds.push_back(id);
                //outWarning += "Fall Confirmed: N/M + Verified. ";
                //printf("[FallDetector] CONFIRMED FALL Obj %d (Count %d/%d). BedExit:%d Shrink:%d (Frame %lld)\n", 
                //        id, count, N, condition_bed_exit, condition_block_shrink, currentFrameIdx);
                continue;
            }


             // Met Primary N-out-of-M condition.
             bool condition_bed_exit = false;
             bool condition_block_shrink = false;
             
             // Scan this object's history in the window to find evidence
             bool was_inside = false;
             bool is_outside_now = false; // "Now" implies end of window or specific transition
             
             float max_blocks = 0;
             int max_blocks_frame = 0;
             float current_blocks = 0;
             float max_avg_dy = -999.0f; // Track max downward velocity
             
             // To be robust, let's find the Object's state at the END (T-1) and ANY START point
             // Actually, Bed Exit is a transition.
             
             // Scan Pass
             for(int f = start; f < T; f++) 
             {
                long long actual_frame_num = currentFrameIdx - (T - 1 - f);
                 for(const auto& obj : history[f]) 
                 {
                     if (obj.id == id) 
                     {
                         // Track Max Dy (Downward is Positive)
                         if (obj.avgDy > max_avg_dy) max_avg_dy = obj.avgDy;

                         float px = (obj.centerX + 0.5f) * (frame_width / (float)grid_cols);
                         float py = (obj.centerY + 0.5f) * (frame_height / (float)grid_rows);
                         //printf("[Algo] Frame %d, obj.id : %d, obj.Center(Blk): %.2f,%.2f -> (Pix): %.2f,%.2f\n", currentFrameIdx - (T-1-f), obj.id, obj.centerX, obj.centerY, px, py);
                         if (f==(T-1))
                         {
                            if (has_bed_poly) 
                            {
                                // Use Centroid check
                                if (isPointInConvexQuad(bed_poly, px, py)) 
                                {
                                    //was_inside = true;
                                } 
                                else 
                                {
                                    is_outside_now = true;
                                    //printf("[%d] is_outside_now: %d (Frame %lld)\n", f, is_outside_now, currentFrameIdx);
                                }
                            } 
                            else 
                            {
                                // Fallback to Safe Area Ratio
                                //if (obj.safe_area_ratio > 0.5f) was_inside = true;
                                if (obj.safe_area_ratio < 0.3f) is_outside_now = true; 
                            }
                        }
                        else
                        {
                            if (has_bed_poly) 
                            {
                                // Use Centroid check
                                if (isPointInConvexQuad(bed_poly, px, py)) 
                                {
                                    was_inside = true;
                                    //printf("[%d] was_inside: %d (Frame %lld)\n", f, was_inside, currentFrameIdx);
                                } 
                                else 
                                {
                                    //is_outside_now = true;
                                }
                            } 
                            else 
                            {
                                // Fallback to Safe Area Ratio
                                if (obj.safe_area_ratio > 0.5f) was_inside = true;
                                //if (obj.safe_area_ratio < 0.3f) is_outside_now = true; 
                            }
                        }
                        if ((float)obj.blocks.size() > max_blocks) 
                        {
                            max_blocks = (float)obj.blocks.size();
                            max_blocks_frame = actual_frame_num;
                            //printf("[Debug] max_blocks %f\n", max_blocks);
                        }
                        current_blocks = (float)obj.blocks.size(); // Keeps updating to latest
                        //printf("[Debug] current_blocks %f\n", current_blocks); 
                     }
                     
                 }
             }
             
             // Check Bed Exit (Must have been inside, and is now effectively outside)
             // We can check if "is_outside_now" (at some point or end) AND "was_inside"
             // AND check if there was significant downward motion (Fall) vs just walking (Horizontal)
             // Check Bed Exit (Must have been inside, and is now effectively outside)
             // AND check if there was significant downward motion (Fall) vs just walking (Horizontal)
             // Check Bed Exit (Must have been inside, and is now effectively outside)
             if (was_inside && is_outside_now)
             {
                 bool confirmed = false;
                 if (enable_bed_exit_verification) {
                    if (max_avg_dy > 2.0f) {
                        confirmed = true;
                        printf("[FallDetector] Bed Exit CONFIRMED for Obj %d (MaxDy: %.2f). Frame %lld\n", id, max_avg_dy, currentFrameIdx);
                    } else {
                        printf("[FallDetector] Bed Exit IGNORED for Obj %d (MaxDy: %.2f < 2.0). Frame %lld\n", id, max_avg_dy, currentFrameIdx);
                    }
                 } else {
                     // Verification Disabled: Trust the primary signal + region transition
                     confirmed = true;
                     printf("[FallDetector] Bed Exit (No Verify) for Obj %d. Frame %lld\n", id, currentFrameIdx);
                 }
                 
                 if (confirmed) condition_bed_exit = true;
             }
             
             // Check Block Shrink
             // Check Block Shrink
             if (max_blocks > 0 && current_blocks > 0) 
             {
                 float ratio = current_blocks / max_blocks;
                 if (ratio < 0.4f) 
                 {
                    bool confirmed = false;
                    if (enable_block_shrink_verification) {
                        if (max_avg_dy > 2.0f) {
                            confirmed = true;
                            printf("[FallDetector] Block Shrink CONFIRMED (Ratio %.2f, MaxDy %.2f)\n", ratio, max_avg_dy);
                        } else {
                            printf("[FallDetector] Block Shrink IGNORED (Ratio %.2f, MaxDy %.2f < 2.0)\n", ratio, max_avg_dy);
                        }
                    } else {
                        // Verification Disabled
                        confirmed = true;
                        printf("[FallDetector] Block Shrink (No Verify) (Ratio %.2f)\n", ratio);
                    }
                    if (confirmed) condition_block_shrink = true;
                 }
             }
             
             // FINAL DECISION
             if (condition_bed_exit || condition_block_shrink) {
                 outTriggeredIds.push_back(id);
                 outWarning += "Fall Confirmed: N/M + Verified. ";
                 printf("[FallDetector] CONFIRMED FALL Obj %d (Count %d/%d). BedExit:%d Shrink:%d (Frame %lld)\n", 
                        id, count, N, condition_bed_exit, condition_block_shrink, currentFrameIdx);
             }
        }
    }
}

// ==================================================================================
//  FallDetector::Impl
// ==================================================================================




// Create Trapezoid Mask
::Image createTrapezoidMask(int width, int height, const std::vector<std::pair<float, float>>& points) {
    ::Image mask(width, height, 1);
    // Fill with 255 (Background / Safe Area?) -> Logic from C_V2.cpp says:
    // "createTrapezoidMask... mask.at(x,y) = 0" for inside trapezoid?
    // But we don't want to break signature too much.
    // Actually, let's just make it a method of Impl or pass it.
    // For now, I will skip detailed pixel check inside this loop and do it AFTER.
    // Or better, update function signature.
    // C_V2.cpp: inside trapezoid => 0 (mask). 
    // Wait, let's check usage in C_V2.cpp:
    // binary_diff.at(x,y) = (...) & bedRegion.at(x, y);
    // If inside bed is SAFER/IGNORED, then it should be 0.
    // If inside bed is where we CARE, it should be 255.
    // C_V2.cpp comment: "在床的區域內會被刪掉" (Deleted in bed region).
    // So bed region = 0, Outside = 255.
    // This means we detect motion OUTSIDE the bed.
    
    // Initialize 255
    uint8_t* data = mask.getData();
    std::fill(data, data + width * height, 255);

    if (points.size() != 4) return mask;

    int minX = width, maxX = 0, minY = height, maxY = 0;
    for (const auto& p : points) {
        if (p.first < minX) minX = std::max(0, (int)p.first);
        if (p.first > maxX) maxX = std::min(width - 1, (int)p.first);
        if (p.second < minY) minY = std::max(0, (int)p.second);
        if (p.second > maxY) maxY = std::min(height - 1, (int)p.second);
    }

    for (int y = minY; y <= maxY; ++y) {
        for (int x = minX; x <= maxX; ++x) {
            if (isPointInConvexQuad(points, x, y)) {
                // Inside bed -> 0
                mask.at(x, y) = 0;
            }
        }
    }
    return mask;
}

// Alias or Wrapper for Bed Region Mask
::Image createBedRegionMask(int width, int height, const std::vector<std::pair<int, int>>& points) {
    std::vector<std::pair<float, float>> floatPoints;
    for(auto& p : points) floatPoints.push_back({(float)p.first, (float)p.second});
    return createTrapezoidMask(width, height, floatPoints);
}


class FallDetector::Impl {
public:
    std::unique_ptr<OptimizedBlockMotionEstimator> estimator;
    std::vector<MotionObject> current_objects;
    std::vector<std::vector<MotionObject>> object_history;
    InternalConfig config; // Use unified Config
    
    // New fields
    // Bed Region
    std::vector<std::pair<int, int>> bed_region = {{0,0}, {100,0}, {100,100}, {0,100}}; // Default

    // Logic
    int fall_confirmation_counter = 0;
    bool in_fall_state = false;
    long long absolute_frame_count = 0; // Persistent frame counter

    // Face Detector
    FaceDetector faceDetector;
    // bool face_model_inited = false; // Removed duplicate
    
    // Profiling
    struct ProfilingData {
        long long total_time = 0;
        long long motion_est_time = 0;
        long long face_detect_time = 0; // Resize + Detect
        long long fall_logic_time = 0;
        int frame_count = 0;
        
        void Reset() {
             total_time = 0; 
             motion_est_time = 0; 
             face_detect_time = 0; 
             fall_logic_time = 0;
             frame_count = 0;
        }
    } prof;

    // Helper for timing
    long long get_now_us() {
        struct timespec ts;
        clock_gettime(CLOCK_MONOTONIC, &ts);
        return (long long)ts.tv_sec * 1000000 + ts.tv_nsec / 1000;
    }
    ::Image bedMask;
    bool hasBedMask = false;

    VisionSDKCallback callback;
    bool is_bed_exit = false; // Current frame status
    uint64_t last_timestamp = 0; // Timestamp of previous frame
    std::vector<MotionObject> previous_objects; // Added for tracking
    int frame_idx = 0; // Added frame_idx definition
    
    // Fix: Move static variable from Detect() to here
    int fall_consecutive_frames = 0;
    
    // Bed Exit History: stores {inside_ratio, outside_ratio}
    std::deque<std::pair<float, float>> bed_stats_history;

    // --- Future-Based Post-Fall Check ---
    struct FallCandidate {
        int id;
        float startX;
        float startY;
        int frames_monitored;
        int max_dist_detected; // Just for debug
    };
    std::vector<FallCandidate> candidates;
    bool was_inside_bed = false; // State tracking

    // Face Model Init State
    bool face_model_inited = false;
    
    // Tracking
    std::map<int, KalmanFilter> kalmanFilters;
    int global_id_counter = 1000;

    Impl() {
        // Initialize estimator with default config
        estimator = std::unique_ptr<OptimizedBlockMotionEstimator>(
            new OptimizedBlockMotionEstimator(config.grid_cols, config.grid_rows, config.block_size, config.search_range)
        );
        estimator->setDiffCheckRange(config.history_size);
        estimator->setSearchMode(config.search_mode);
    }
// ... (skip vectors)
    // Vectors reused per frame
    std::vector<MotionVector> motion_vectors;
    std::vector<BlockPosition> positions;
    std::vector<bool> changed_mask;
    std::vector<::Image> active_blocks;
    std::vector<int> active_indices;
    
    // Background Update Logic
    ::Image backgroundFrame;
    int bg_update_counter = 0;
    std::vector<int32_t> bg_accumulator; // For accumulating frames during init
    int bg_accumulated_count = 0;
    
    void updateBackground(const ::Image& current, const InternalConfig& cfg, int frame_idx) {
        if (backgroundFrame.width() != current.width() || backgroundFrame.height() != current.height()) {
            backgroundFrame = current.clone();
            // Reset accumulator if size changes
            bg_accumulator.assign(current.width() * current.height() * current.getChannels(), 0);
            bg_accumulated_count = 0;
            return;
        }
        
        // 1. Initialization Phase (Average Logic)
        if (cfg.bg_init_start_frame > 0 && cfg.bg_init_end_frame > cfg.bg_init_start_frame) {
            if (frame_idx >= cfg.bg_init_start_frame && frame_idx <= cfg.bg_init_end_frame) {
                int size = current.width() * current.height() * current.getChannels();
                if(bg_accumulator.size() != size) bg_accumulator.resize(size, 0);
                
                const unsigned char* curr_ptr = current.getData();
                for(int i=0; i<size; ++i) {
                    bg_accumulator[i] += curr_ptr[i];
                }
                bg_accumulated_count++;
                
                // If this is the END frame, compute average
                if (frame_idx == cfg.bg_init_end_frame && bg_accumulated_count > 0) {
                     unsigned char* bg_ptr = backgroundFrame.getData();
                     for(int i=0; i<size; ++i) {
                         bg_ptr[i] = (unsigned char)(bg_accumulator[i] / bg_accumulated_count);
                     }
                     // Clear accumulator
                     std::vector<int32_t>().swap(bg_accumulator);
                     bg_accumulated_count = 0;
                }
                return; // During init, don't run normal update
            }
        }
        
        // 2. Periodic Update Phase
        float alpha = cfg.bg_update_alpha;
        if (alpha <= 0.0f) return;
        
        // Weighted Average
        // bg = (1-alpha)*bg + alpha*curr
        int alpha_int = (int)(alpha * 256.0f);
        if (alpha_int < 0) alpha_int = 0;
        if (alpha_int > 256) alpha_int = 256;
        int inv_alpha = 256 - alpha_int;
        
        int size = current.width() * current.height() * current.getChannels();
        unsigned char* bg_ptr = backgroundFrame.getData();
        const unsigned char* curr_ptr = current.getData();  
        
        for(int i=0; i<size; ++i) {
            int val = (bg_ptr[i] * inv_alpha + curr_ptr[i] * alpha_int) >> 8;
            bg_ptr[i] = (unsigned char)val;
        }
    }
};

FallDetector::FallDetector() : pImpl(std::make_shared<Impl>()) {}
FallDetector::~FallDetector() = default;


void FallDetector::SetConfig(const InternalConfig& config) {
    bool gridChanged = (config.grid_cols != pImpl->config.grid_cols ||
                        config.grid_rows != pImpl->config.grid_rows ||
                        config.block_size != pImpl->config.block_size ||
                        config.search_range != pImpl->config.search_range);
    
    pImpl->config = config; // Update internal config

    if (gridChanged) {
        pImpl->estimator.reset(new OptimizedBlockMotionEstimator(
            config.grid_cols, config.grid_rows, config.block_size, config.search_range));
    }
    
    pImpl->estimator->setDiffCheckRange(config.history_size);
    pImpl->estimator->setSearchMode(config.search_mode);
    pImpl->estimator->setBlockDecay(config.enable_block_decay, config.block_decay_frames);
    pImpl->estimator->setBlockDilation(config.enable_block_dilation);

    // Re-verify bed region
    if (!pImpl->bed_region.empty()) {
        pImpl->bedMask = createBedRegionMask(800, 600, pImpl->bed_region); // Assume size or handle resize dynamically?
    }
    pImpl->hasBedMask = !pImpl->bed_region.empty();

    // Initialize Face Detector
    // Update Verification Flags - Handled in HermesII_sdk.cpp via pImpl->config

    if (!pImpl->face_model_inited) {
         std::cout << "[FallDetector::SetConfig] Initializing FaceDetector..." << std::endl;
         StatusCode ret = pImpl->faceDetector.Init("res/blaze_face_detect_nnp310_128x128.ty");
         if (ret != StatusCode::OK) {
             std::cout << "[FallDetector::SetConfig] FaceDetector Init Failed: " << (int)ret << std::endl;
             // Do NOT set true, allows retry on next Config call or manually? 
             // Actually, Config is usually called once. If it fails, maybe we should try in Detect too?
             // But let's stick to Config first.
         } else {
             std::cout << "[FallDetector::SetConfig] FaceDetector Init OK" << std::endl;
             pImpl->face_model_inited = true;
         }
    }
}

void FallDetector::SetBedRegion(const std::vector<std::pair<int, int>>& points) {
    pImpl->bed_region = points;
    // Invalidate mask, will be recreated in Detect() when frame size is known
    pImpl->hasBedMask = false; 
    if (!points.empty()) pImpl->hasBedMask = true; // Signal that we have a region
    pImpl->bedMask = ::Image(); // Clear
}


void FallDetector::RegisterCallback(VisionSDKCallback cb) {
    pImpl->callback = cb;
}

void FallDetector::SetHistorySize(int n) {
  pImpl->config.history_size = n;
  if(pImpl->estimator) pImpl->estimator->setDiffCheckRange(n);
}

// Removed SetBedRegion and SetTrapPoints as they are replaced by LoadBedRegion
// void FallDetector::SetBedRegion(const ::Image& bedRegion) {
//     pImpl->bedRegion = bedRegion.clone();
// }

// void FallDetector::SetTrapPoints(const std::vector<std::pair<float, float>>& points) {
//     pImpl->trapPoints = points;
// }



// Helper: Calculate Overlap Percentage (Block Intersection / Prev Size)
float calculateOverlap(const MotionObject& curr, const MotionObject& prev) {
    if (prev.blocks.empty()) return 0.0f;
    int intersection = 0;
    // Assuming blocks are sorted or we use a set for O(N log N) or unsorted O(N*M)
    // Since vectors are small (blocks), O(N*M) is fine.
    for (int cb : curr.blocks) {
        for (int pb : prev.blocks) {
            if (cb == pb) {
                intersection++;
                break;
            }
        }
    }
    return (float)intersection / prev.blocks.size();
}

void TrackObjects(std::vector<MotionObject>& current, const std::vector<MotionObject>& previous, 
                  const InternalConfig& config, 
                  std::map<int, KalmanFilter>& kalmanFilters,
                  int& global_id_counter) 
{
    float threshold = config.tracking_overlap_threshold;
    int mode = config.tracking_mode; // 1=Original, 2=Hungarian, 3=Kalman, 4=SORT

    if (previous.empty()) {
        for (auto& obj : current) {
             if (obj.id < 1000) obj.id = global_id_counter++; // New ID
             obj.trajectory.push_back({(int)obj.centerX, (int)obj.centerY});
             
             // Init Kalman for new objects (Mode 3/4)
             if (mode >= 3) {
                 KalmanFilter kf(obj.centerX, obj.centerY);
                 kalmanFilters.insert({obj.id, kf});
             }
        }
        return;
    }

    // --- MODE 1: ORIGINAL (Greedy based on Overlap + Distance with Split/Merge) ---
    if (mode == 1) {
        // Association Map: Curr -> [Prev Indices]
        std::map<int, std::vector<int>> currToPrev;
        std::map<int, std::vector<int>> prevToCurr;

        // 1. Identify Overlaps
        for (size_t i = 0; i < current.size(); ++i) {
            for (size_t j = 0; j < previous.size(); ++j) {
                float overlap = calculateOverlap(current[i], previous[j]);
                bool is_match = false;
                if (overlap > threshold) {
                    is_match = true;
                } else {
                    float dx = current[i].centerX - previous[j].centerX;
                    float dy = current[i].centerY - previous[j].centerY;
                    float dist = std::sqrt(dx*dx + dy*dy);
                    if (dist < 3.0f) is_match = true;
                }
                
                if (is_match) {
                    currToPrev[i].push_back(j);
                    prevToCurr[j].push_back(i);
                }
            }
        }

        // 2. Process Associations (Split/Merge/Match)
        // Case A: Split (One Prev -> Many Curr)
        for (auto const& item : prevToCurr) {
            int prevIdx = item.first;
            auto& currIndices = item.second;
            if (currIndices.size() > 1) {
                const auto& pObj = previous[prevIdx];
                float sumX = 0, sumY = 0;
                for (int objIdx : currIndices) {
                     sumX += current[objIdx].centerX;
                     sumY += current[objIdx].centerY;
                }
                float avgX = sumX / currIndices.size();
                float avgY = sumY / currIndices.size();
                
                for (int objIdx : currIndices) {
                    current[objIdx].id = pObj.id;
                    current[objIdx].trajectory = pObj.trajectory;
                    current[objIdx].trajectory.push_back({(int)avgX, (int)avgY});
                    current[objIdx].acceleration = current[objIdx].strength - pObj.strength;
                }
            }
        }

        // Case B: Merge or 1-to-1
        for (auto const& item : currToPrev) {
            int currIdx = item.first;
            auto& prevIndices = item.second;
             if (prevIndices.size() > 1) {
                 // Merge
                 int minID = 999999;
                 int bestPrevIdx = -1;
                 for (int pIdx : prevIndices) {
                     if (previous[pIdx].id < minID) {
                         minID = previous[pIdx].id;
                         bestPrevIdx = pIdx;
                     }
                 }
                 // Logic: Inherit Smallest ID
                 current[currIdx].id = minID;
                 current[currIdx].trajectory = previous[bestPrevIdx].trajectory;
                 float avgPrevStrength = 0;
                 for (int pIdx : prevIndices) avgPrevStrength += previous[pIdx].strength;
                 avgPrevStrength /= prevIndices.size();
                 current[currIdx].acceleration = current[currIdx].strength - avgPrevStrength;
                 current[currIdx].trajectory.push_back({(int)current[currIdx].centerX, (int)current[currIdx].centerY});
             } 
             else if (prevIndices.size() == 1) {
                 int pIdx = prevIndices[0];
                 if (prevToCurr[pIdx].size() == 1) {
                     // 1-to-1
                     current[currIdx].id = previous[pIdx].id;
                     current[currIdx].trajectory = previous[pIdx].trajectory;
                     current[currIdx].trajectory.push_back({(int)current[currIdx].centerX, (int)current[currIdx].centerY});
                     current[currIdx].acceleration = current[currIdx].strength - previous[pIdx].strength;
                 }
             }
        }
    }
    // --- MODE 2, 3, 4: Standard Matching (1-to-1) ---
    else {
        // Prepare Cost Matrix
        // Rows: Previous Objects
        // Cols: Current Objects
        int rows = previous.size();
        int cols = current.size();
        std::vector<std::vector<float>> costMatrix(rows, std::vector<float>(cols));

        // Predict Kalman Filters if needed
        std::vector<std::pair<float, float>> predPositions(rows);
        if (mode >= 3) {
            for (int i=0; i<rows; ++i) {
                int id = previous[i].id;
                if (kalmanFilters.count(id)) {
                    kalmanFilters.at(id).Predict();
                    kalmanFilters.at(id).GetState(predPositions[i].first, predPositions[i].second);
                } else {
                    predPositions[i] = {previous[i].centerX, previous[i].centerY};
                }
            }
        }

        for (int i = 0; i < rows; ++i) {
            for (int j = 0; j < cols; ++j) {
                float cost = 0;
                if (mode == 2) { 
                    // Hungarian on Overlap/Dist
                    float overlap = calculateOverlap(current[j], previous[i]);
                    if (overlap > 0) cost = 1.0f - overlap; 
                    else {
                         float dx = current[j].centerX - previous[i].centerX;
                         float dy = current[j].centerY - previous[i].centerY;
                         cost = std::sqrt(dx*dx + dy*dy) + 10.0f; // Penalize distance
                    }
                } else { 
                    // Kalman/SORT: Euclidean Distance between Predicted and Current
                    float px = predPositions[i].first;
                    float py = predPositions[i].second;
                    float dx = current[j].centerX - px;
                    float dy = current[j].centerY - py;
                    cost = std::sqrt(dx*dx + dy*dy);
                }
                
                // Gating (optional): If cost too high, make it infinity?
                if (cost > 100.0f) cost = 99999.0f;
                costMatrix[i][j] = cost;
            }
        }

        std::vector<int> assignment;
        if (mode == 3) {
            // Greedy Matching based on Cost Matrix (not using Hungarian)
            // Just pick min cost iteratively
             assignment.assign(rows, -1);
             std::vector<bool> colUsed(cols, false);
             // Simple greedy: for each row, find best available col
             // Better greedy: Find global min, assign, repeat.
             // Simpler implementation: iterate rows, find min col.
             // This is prone to order bias. A true greedy sorts all edges.
             // Let's use a simple row-wise min for "Mode 3 = Light/Fast"
             for(int i=0; i<rows; ++i) {
                 float minC = 9999.0f;
                 int bestJ = -1;
                 for(int j=0; j<cols; ++j) {
                     if(!colUsed[j] && costMatrix[i][j] < minC) {
                         minC = costMatrix[i][j];
                         bestJ = j;
                     }
                 }
                 if(bestJ != -1 && minC < 50.0f) { // Gating threshold
                     assignment[i] = bestJ;
                     colUsed[bestJ] = true;
                 }
             }
        } else {
            // Hungarian (Mode 2 & 4)
            assignment = HungarianAlgorithm::Solve(costMatrix);
        }

        // Apply Assignment using assignment vector (Prev[i] -> Curr[assignment[i]])
        std::vector<bool> currentMatched(cols, false);
        
        for (int i = 0; i < rows; ++i) {
            int j = assignment[i];
            if (j >= 0 && j < cols) {
                // Check Gating (if Hungarian didn't respect infinity)
                if (costMatrix[i][j] > 50.0f) { // Max distance threshold (e.g., 50 pixels/units)
                     continue; // Invalid match
                }
                
                // Match Found
                currentMatched[j] = true;
                current[j].id = previous[i].id;
                current[j].trajectory = previous[i].trajectory;
                current[j].trajectory.push_back({(int)current[j].centerX, (int)current[j].centerY});
                current[j].acceleration = current[j].strength - previous[i].strength;
                
                // Update Kalman
                if (mode >= 3) {
                    if (kalmanFilters.count(current[j].id)) {
                        kalmanFilters.at(current[j].id).Update(current[j].centerX, current[j].centerY);
                    } else {
                        // Resurrected or missing filter? Create new if missing.
                         KalmanFilter kf(current[j].centerX, current[j].centerY);
                         kalmanFilters.insert({current[j].id, kf});
                    }
                }
            } else {
                // Prev[i] lost. Remove from Kalman map? 
                // We typically keep for a few frames (coasting), but here we hard remove?
                // Let's remove immediately for simplicity to avoid memory growth.
                if (mode >= 3) kalmanFilters.erase(previous[i].id);
            }
        }
        
        // Handle Unmatched Current Objects (New IDs)
        // ... (Fall through to logic below)
        // Helper loop for unassigned new objects
        for(int j=0; j<cols; ++j) {
            if(!currentMatched[j]) {
                // Assign New ID
                if (current[j].id < 1000) current[j].id = global_id_counter++;
                 current[j].trajectory.push_back({(int)current[j].centerX, (int)current[j].centerY});
                 
                 // Init Kalman
                 if (mode >= 3) {
                     KalmanFilter kf(current[j].centerX, current[j].centerY);
                     kalmanFilters.insert({current[j].id, kf});
                 }
            }
        }
    }

    // Process final unmatched/new objects (Common handling for Mode 1 as well)
    // Mode 1 loop for "New Objects" was separate.
    if (mode == 1) {
        for (auto& obj : current) {
            if (obj.trajectory.empty()) {
                if (obj.id < 1000) obj.id = global_id_counter++;
                obj.trajectory.push_back({(int)obj.centerX, (int)obj.centerY});
            }
        }
    }
}

StatusCode FallDetector::Detect(const Image& frame, bool& is_fall) {
    is_fall = false;
    pImpl->absolute_frame_count++; // Increment frame counter
  
    // 0. Timestamp Validation
    if (pImpl->config.expected_frame_interval_ms > 0 && pImpl->last_timestamp > 0) {
        uint64_t diff = frame.timestamp - pImpl->last_timestamp;
        int error = std::abs((int)diff - pImpl->config.expected_frame_interval_ms);
        
        if (error > pImpl->config.frame_interval_tolerance_ms) {
            printf("[FallDetector] Timestamp Discontinuity Error! Diff: %lu ms, Expected: %d ms\n", 
                   diff, pImpl->config.expected_frame_interval_ms);
            pImpl->last_timestamp = frame.timestamp; 
            return StatusCode::ERROR_TIMESTAMP_DISCONTINUITY;
        }
    }
    pImpl->last_timestamp = frame.timestamp;

    int W = frame.width;
    int H = frame.height;
    
    // Resize mask check
    if (pImpl->hasBedMask && (pImpl->bedMask.width() != W || pImpl->bedMask.height() != H)) {
         pImpl->bedMask = createBedRegionMask(W, H, pImpl->bed_region);
    }
  
    // 1. Motion Estimation
    #if ENABLE_PERF_PROFILING
    long long t0 = pImpl->get_now_us();
    #endif

    // Needs Gray Image (1 channel) for correct stride/SAD in OptimizedBlockMotionEstimator
    ::Image wrapper(W, H, 1);
    
    if (frame.channels == 3) {
        // Simple RGB -> Gray Conversion
        const uint8_t* src = frame.data;
        uint8_t* dst = wrapper.getData();
        int size = W * H;
        for (int i = 0; i < size; ++i) {
            // Y = 0.299R + 0.587G + 0.114B
            // Fast approximation: (R + 2G + B) / 4 or just G
            int r = src[i*3];
            int g = src[i*3+1];
            int b = src[i*3+2];
            dst[i] = (uint8_t)((r*77 + g*150 + b*29) >> 8); // integer approx for standard weights
        }
    } else if (frame.channels == 1) {
        memcpy(wrapper.getData(), frame.data, W * H);
    }

    // V3: Background Update Logic (Using Gray Image)
    // Background Update
    if (pImpl->config.bg_update_interval_frames > 0) {
        pImpl->bg_update_counter++;
        bool isInitPhase = (pImpl->frame_idx >= pImpl->config.bg_init_start_frame && pImpl->frame_idx <= pImpl->config.bg_init_end_frame);
        
        if (isInitPhase || (pImpl->bg_update_counter >= pImpl->config.bg_update_interval_frames)) {
            // Only periodic update if NOT in init phase (init phase handled inside updateBackground)
            // Wait, updateBackground logic handles check.
            pImpl->updateBackground(wrapper, pImpl->config, pImpl->frame_idx);
            if (!isInitPhase) pImpl->bg_update_counter = 0;
        }
    }
    
    // Generate and Save BG Mask
    if (pImpl->config.enable_save_bg_mask) {
        // Only if BG is ready
        if (pImpl->backgroundFrame.width() > 0) {
            // Create Binary Mask
            int w = wrapper.width();
            int h = wrapper.height();
            // Assuming wrapper is Grayscale? Yes, convertToGrayscale called earlier.
            // But backgroundFrame might be 3 channel if initialized from RGB? 
            // Previous code initialized `backgroundFrame` from `wrapper` (which is Gray).
            // So logic holds.
            
            std::vector<unsigned char> maskData(w * h);
            const unsigned char* curr = wrapper.getData();
            const unsigned char* bg = pImpl->backgroundFrame.getData();
            int diff_thr = pImpl->config.bg_diff_threshold;
            
            for(int i=0; i<w*h; ++i) {
                // If in Bed -> 128 (Need Bed Mask)
                // Bed Mask Logic: pImpl->bedMask or implementation specific?
                // pImpl->bedMask exists? No, logic depends on bed_region vector.
                // We should reconstruct bed mask if needed, but for now we iterate points?
                // `SetBedRegion` only stores points.
                // Let's assume bedMask check is manual
                
                // Bed Mask Logic: 
                // Based on existing logic (line 1800), 255 = Outside, 0 = Inside.
                // User wants Bed Region (Inside) to be 128.
                // So if mask == 0, set 128.
                int val = 0;
                unsigned char pix_diff = (unsigned char)std::abs((int)curr[i] - (int)bg[i]);
                
                if (pImpl->hasBedMask && pImpl->bedMask.getData()[i] == 0) {
                     // Inside Bed
                     val = 128; // User requested Bed Area = 128 (Fixed, no diff check?)
                     // User said "Bed area not judged, fixed to 128" -> "床的區域不判斷 固定為128"
                } else {
                    // Outside Bed
                    if (pix_diff > diff_thr) val = 255;
                    else val = 0;
                }
                maskData[i] = (unsigned char)val;
            }
            
            // Save
            char filename[256];
            // Ensure directory check (handled by caller possibly, but we should be safe)
            std::string savePath = pImpl->config.save_image_path.empty() ? "." : pImpl->config.save_image_path;
            snprintf(filename, sizeof(filename), "%s/bg_mask_%05d.bmp", savePath.c_str(), pImpl->frame_idx);
            
            // SaveBMP (Minimal logic, header+data)
            FILE* f = fopen(filename, "wb");
            if(f) {
                // Grayscale BMP Header? Or standard 24bit?
                // 8-bit BMP requires Palette. 24-bit is easier.
                // Let's save as 24-bit BGR for compatibility.
                int filesize = 54 + 3 * w * h;
                unsigned char bmpfileheader[14] = {'B','M', 0,0,0,0, 0,0,0,0, 54,0,0,0};
                unsigned char bmpinfoheader[40] = {40,0,0,0, 0,0,0,0, 0,0,0,0, 1,0, 24,0};
                
                bmpfileheader[ 2] = (unsigned char)(filesize);
                bmpfileheader[ 3] = (unsigned char)(filesize>>8);
                bmpfileheader[ 4] = (unsigned char)(filesize>>16);
                bmpfileheader[ 5] = (unsigned char)(filesize>>24);

                bmpinfoheader[ 4] = (unsigned char)(w);
                bmpinfoheader[ 5] = (unsigned char)(w>>8);
                bmpinfoheader[ 6] = (unsigned char)(w>>16);
                bmpinfoheader[ 7] = (unsigned char)(w>>24);
                bmpinfoheader[ 8] = (unsigned char)(h); 
                bmpinfoheader[ 9] = (unsigned char)(h>>8); // Negative for Top-Down? No, standard is Bottom-Up.
                // If we want raw save, let's use +h (Top-Down inverse usually)
                // Standard BMP: Height > 0 means Bottom-Up.
                // Our data is Top-Down. To save correctly, we should flip or use negative height (some viewers support).
                // Let's use negative height for Top-Down order if header allows (V5/V4 header).
                // But simplified here: Just write Top-Down data with +Height -> Image will be flipped.
                // We'll flip row writing.
                bmpinfoheader[11] = (unsigned char)(h>>24);

                fwrite(bmpfileheader,1,14,f);
                fwrite(bmpinfoheader,1,40,f);
                
                int pad = (4 - (w * 3) % 4) % 4;
                unsigned char bmppad[3] = {0,0,0};
                
                // Write Bottom-Up (h-1 to 0)
                for(int y=h-1; y>=0; y--) {
                    for(int x=0; x<w; x++) {
                        unsigned char v = maskData[y*w+x];
                        unsigned char pixel[3] = {v,v,v};
                        fwrite(pixel, 1, 3, f);
                    }
                    fwrite(bmppad, 1, pad, f);
                }
                fclose(f);
            }
        }
    } 
    #if ENABLE_PERF_PROFILING
    long long t1 = pImpl->get_now_us(); // Wrapper Init (Part of Motion Est prep)
    #endif

    #if ENABLE_PERF_PROFILING
    long long t2 = pImpl->get_now_us(); // Motion Est (placeholder, actual ME is below blockBasedMotionEstimation)
    // Wait, blockBasedMotionEstimation is called later!
    // Moving t1, t2 logic...
    // The previous block was JUST image conversion.
    #endif

    // --- 0. Face Detection Integration ---
    #if ENABLE_PERF_PROFILING
    long long t_face_start = pImpl->get_now_us();
    #endif

    bool has_face = false;
    FaceROI face_roi = {0,0,0,0,0.0f};

    // Retry Init if failed in Config (Optional, or just rely on SetConfig)
    if (pImpl->config.enable_face_detection && !pImpl->face_model_inited) {
         // Try one more time? Or just skip?
         // Let's print warning once?
         // Or try to init again?
         StatusCode ret = pImpl->faceDetector.Init("res/blaze_face_detect_nnp310_128x128.ty");
         if (ret == StatusCode::OK) {
              pImpl->face_model_inited = true;
         } else {
             // Print error every 100 frames to avoid spam?
             // Just print error
             std::cout << "[FallDetector::Detect] FaceDetector not initialized (Retry Failed: " << (int)ret << ")" << std::endl;
         }
    }

    // Resize for Face Detection (Uses RGB frame)
    Image faceInput;
    // std::cout << "[FallDetector] Calling FaceDetector Resize..." << std::endl; // Commented out
    if (pImpl->config.enable_face_detection) {
        if (pImpl->faceDetector.Resize(frame, faceInput)) {
             // std::cout << "[FallDetector] Resize success. Calling Detect..." << std::endl;
             std::vector<FaceROI> faces;
             int ret = pImpl->faceDetector.Detect(faceInput, faces);
             // std::cout << "[FallDetector] Detect returned " << ret << " num_faces=" << faces.size() << std::endl;
             if (ret == 0 && !faces.empty()) {
                 has_face = true;
                 face_roi = faces[0]; 
             }
        } else {
            // std::cout << "[FallDetector] Resize failed!" << std::endl;
        }
    }
    
    #if ENABLE_PERF_PROFILING
    long long t_face_end = pImpl->get_now_us();
    pImpl->prof.face_detect_time += (t_face_end - t_face_start);
    #endif
    
    #if ENABLE_PERF_PROFILING
    long long t_me_start = pImpl->get_now_us();
    #endif

    // Run Block Motion Estimation (Optimized or Standard)
    // The original code had `pImpl->motion_vectors` and `pImpl->positions`, `pImpl->changed_mask`, `pImpl->active_blocks`, `pImpl->active_indices`
    // The new code uses `pImpl->motion_map` and `pImpl->config.motion_config`.
    // Assuming `pImpl->estimator->blockBasedMotionEstimation` signature has changed or `motion_map` encapsulates these.
    // For now, I'll keep the original call and add the profiling around it.
    pImpl->is_bed_exit = false; 
    pImpl->estimator->blockBasedMotionEstimation(wrapper, 
                                               pImpl->motion_vectors, 
                                               pImpl->positions, 
                                               pImpl->changed_mask, 
                                               pImpl->active_blocks, 
                                               pImpl->active_indices,
                                               pImpl->config.block_dilation_threshold);

    #if ENABLE_PERF_PROFILING
    long long t_me_end = pImpl->get_now_us();
    pImpl->prof.motion_est_time += (t_me_end - t_me_start) + (t1 - t0); // Include conversion time
    #endif
    
    #if ENABLE_PERF_PROFILING
    long long t_logic_start = pImpl->get_now_us();
    #endif

    // 2. Extract Objects
    // 2. Extract Objects
    // Save previous
    pImpl->previous_objects = pImpl->current_objects;
    
    pImpl->current_objects = extractMotionObjects(pImpl->motion_vectors, 
                                                  pImpl->changed_mask,
                                                  pImpl->config.grid_rows, 
                                                  pImpl->config.grid_cols, 
                                                  pImpl->config.object_extraction_threshold, 
                                                  pImpl->config.object_merge_radius);
                                                  
    // TRACKING
    // TRACKING
    TrackObjects(pImpl->current_objects, pImpl->previous_objects, pImpl->config, pImpl->kalmanFilters, pImpl->global_id_counter);
    
    // 2.1 Update Safe Area Ratio
    if (pImpl->hasBedMask) {
        int cols = pImpl->config.grid_cols; 
        int rows = pImpl->config.grid_rows;
        float blockW = (float)W / cols;
        float blockH = (float)H / rows;

        for (auto& obj : pImpl->current_objects) {
            int safe_blocks = 0;
            for (int blkIdx : obj.blocks) {
                int r = blkIdx / cols;
                int c = blkIdx % cols;
                int px = (int)((c + 0.5f) * blockW);
                int py = (int)((r + 0.5f) * blockH);
                if (px >= 0 && px < W && py >= 0 && py < H) {
                     if (pImpl->bedMask.at(px, py) == 0) safe_blocks++;
                }
            }
            if(!obj.blocks.empty())
                obj.safe_area_ratio = (float)safe_blocks / obj.blocks.size();
        }
    }

    // 2.5 Check Bed Exit (Temporal Analysis)
    if (pImpl->hasBedMask) {
        int exit_blocks = 0;   // Blocks OUTSIDE bed
        int inside_blocks = 0; // Blocks INSIDE bed
        int total_motion_blocks = 0;
        
        int cols = pImpl->config.grid_cols;
        int rows = pImpl->config.grid_rows;
        float blockW = (float)W / cols;
        float blockH = (float)H / rows;

        for (size_t i = 0; i < pImpl->motion_vectors.size(); ++i) {
             int r = i / cols;
             int c = i % cols;
             int dx = pImpl->motion_vectors[i].dx;
             int dy = pImpl->motion_vectors[i].dy;
             
             // Check if block has significant motion
             if(dx*dx + dy*dy > 2*2) { 
                total_motion_blocks++;
                int px = (int)((c + 0.5f) * blockW);
                int py = (int)((r + 0.5f) * blockH);
                if (px >= 0 && px < W && py >= 0 && py < H) {
                    // 255 = Outside, 0 = Inside
                    if (pImpl->bedMask.at(px, py) == 255) {
                        exit_blocks++;
                    } else {
                        inside_blocks++;
                    }
                }
             }
        }
        
        // Calculate Ratios
        float inside_ratio = 0.0f;
        float outside_ratio = 0.0f;
        
        if (total_motion_blocks > 5) {
            inside_ratio = (float)inside_blocks / total_motion_blocks;
            outside_ratio = (float)exit_blocks / total_motion_blocks;
        }
        
        // Update History
        pImpl->bed_stats_history.push_back({inside_ratio, outside_ratio});
        if ((int)pImpl->bed_stats_history.size() > pImpl->config.bed_exit_history_len) {
            pImpl->bed_stats_history.pop_front();
        }
        
        // Analyze Trend
        // Only analyze if history is full enough (e.g. > 80% of desired length)
        int required_len = pImpl->config.bed_exit_history_len;
        if ((int)pImpl->bed_stats_history.size() >= required_len * 0.8) {
             int history_size = pImpl->bed_stats_history.size();
             int half_idx = history_size / 2;
             
             float avg_inside_old = 0.0f, avg_outside_old = 0.0f;
             float avg_inside_new = 0.0f, avg_outside_new = 0.0f;
             
             int count_old = 0, count_new = 0;
             for(int i=0; i<history_size; ++i) {
                 if (i < half_idx) {
                     avg_inside_old += pImpl->bed_stats_history[i].first;
                     avg_outside_old += pImpl->bed_stats_history[i].second;
                     count_old++;
                 } else {
                     avg_inside_new += pImpl->bed_stats_history[i].first;
                     avg_outside_new += pImpl->bed_stats_history[i].second;
                     count_new++;
                 }
             }
             if (count_old > 0) { avg_inside_old /= count_old; avg_outside_old /= count_old; }
             if (count_new > 0) { avg_inside_new /= count_new; avg_outside_new /= count_new; }
             
             // Logic: Initially Inside > Outside, Later Outside > Inside
             // Also enforce minimum thresholds to avoid noise
             bool start_inside = (avg_inside_old > avg_outside_old);
             bool end_outside = (avg_outside_new > avg_inside_new);
             
             // Optional: Strict thresholds logic (from config)
             // bool start_inside = (avg_inside_old > pImpl->config.bed_exit_min_inside_ratio);
             // bool end_outside = (avg_outside_new > pImpl->config.bed_exit_min_outside_ratio);
             
             if (start_inside && end_outside) {
                 pImpl->is_bed_exit = true;
             }
        }
    }

    // 3. Fall Logic
    std::string warning = "";
    float max_strength = 0.0f;
    
    // Update object history
    pImpl->object_history.push_back(pImpl->current_objects);
    if (pImpl->object_history.size() > pImpl->config.fall_window_size) {
        pImpl->object_history.erase(pImpl->object_history.begin());
    }

    std::string warningMsg;
    std::vector<int> triggered_ids;
    
    if (pImpl->is_bed_exit == true)
    {
        printf("[Debug] pImpl->absolute_frame_count %d detect Bed Exit.\n", pImpl->absolute_frame_count);
    }

    detectObjectTemporalMotion(
        pImpl->object_history,
        pImpl->config.fall_movement_threshold,
        pImpl->config.fall_strong_threshold,
        pImpl->config.fall_acceleration_threshold,
        pImpl->config.safe_area_ratio_threshold,
        pImpl->config.fall_window_size,
        pImpl->config.fall_duration, // Pass N (Threshold)
        pImpl->config.fall_acceleration_upper_threshold,
        pImpl->config.fall_acceleration_lower_threshold,
        pImpl->bed_region,
        triggered_ids,
        pImpl->absolute_frame_count,
        warningMsg,
        W, H,
        pImpl->config.grid_cols, pImpl->config.grid_rows,
        pImpl->config.enable_bed_exit_verification, // NEW
        pImpl->config.enable_block_shrink_verification // NEW
    );

    is_fall = false;
    if (!triggered_ids.empty() && pImpl->is_bed_exit == true) {
        is_fall = true;
        warning = warningMsg;
        for(int pid : triggered_ids) {
            printf("[FallDetector] *** FALL DETECTED (ID %d) ***\n", pid);
        }
    }
    if (!pImpl->candidates.empty()) 
    {
        std::vector<Impl::FallCandidate> kept_candidates;
        for(auto& c : pImpl->candidates) {
            bool found = false;
            float cx = 0, cy = 0;
            float vx = 0, vy = 0;
            for(const auto& o : pImpl->current_objects) {
                if (o.id == c.id) { 
                    cx = o.centerX; 
                    cy = o.centerY; 
                    vx = o.avgDx;
                    vy = o.avgDy;
                    found = true; 
                    break; 
                }
            }
            
            if (found) {
                 float dist = std::sqrt(pow(cx - c.startX, 2) + pow(cy - c.startY, 2));
                 
                 // Debug: Track Candidate Movement
                 float motion_speed = std::sqrt(pow(vx, 2) + pow(vy, 2));
                 
                 printf("DEBUG: Cand %d (Frame %d/%d) Start(%.1f,%.1f) Curr(%.1f,%.1f) Dist: %.2f (Thresh: %.1f) Speed: %.2f\n", 
                        c.id, c.frames_monitored + 1, pImpl->config.post_fall_check_frames, 
                        c.startX, c.startY, cx, cy, dist, pImpl->config.post_fall_distance_threshold, motion_speed);

                 // REJECTION LOGIC
                 bool rejected = false;
                 // 1. Distance from Start (Legacy)
                 if (dist > pImpl->config.post_fall_distance_threshold) {
                     printf("[FallDetector] Fall Candidate %d REJECTED (Dist: %.2f > %.2f)\n", c.id, dist, pImpl->config.post_fall_distance_threshold);
                     rejected = true;
                 }
                 // 2. Instant Motion Speed (New fix for "observing center movement")
                 // If object is still moving significantly (e.g. walking), reject.
                 // Threshold 2.5?
                 else if (motion_speed > 2.5f) {
                      printf("[FallDetector] Fall Candidate %d REJECTED (Speed: %.2f > 2.5)\n", c.id, motion_speed);
                      rejected = true;
                 }

                 if (rejected) continue; 

                 
                 c.frames_monitored++;
                 if (c.frames_monitored >= pImpl->config.post_fall_check_frames) 
                 {
                     // Confirmed
                     is_fall = true;
                     warning = "FALL DETECTED (Confirmed)! Obj " + std::to_string(c.id);
                     printf("[FallDetector] Fall Candidate %d CONFIRMED.\n", c.id);
                     kept_candidates.push_back(c); 
                 } else {
                     kept_candidates.push_back(c);
                 }
            } else {
                 printf("[FallDetector] Fall Candidate %d LOST.\n", c.id);
            }
        }
        pImpl->candidates = kept_candidates;
    }
    
    // Fallback: If immediate warning exists but no candidates yet (processing delay?), pass it?
    // No, logic is strictly: Trigger -> Monitor -> Confirm.
    // warning = warningMsg; // Don't use raw warningMsg anymore, only confirmed warning. 
    // Is this correct? Yes. But I should probably log warningMsg.
    if (!warningMsg.empty()) {
        // printf("[FallDetector] Instant Trigger: %s\n", warningMsg.c_str());
    }

    // Find max strength for callback, even if not a fall
    // Find max strength for callback, even if not a fall
    for(const auto& obj : pImpl->current_objects) {
        if(obj.strength > max_strength) max_strength = obj.strength;
    }
    
    // Temporal Consistency (Debounce)
    // static int fall_consecutive_frames = 0; // Removed static
    if (is_fall) {
        pImpl->fall_consecutive_frames++;
    } else {
        pImpl->fall_consecutive_frames = 0;
    }
    if (pImpl->fall_consecutive_frames >= pImpl->config.fall_duration) {
         // Keep is_fall = true
    } else {
         //is_fall = false;
         //printf("!!!!!!!!!!!!!!??????\n");
    }

    // 3. Visualization and Saving
    /*
    if (pImpl->config.enable_save_images) {
        ...
        saveBMP_RGB(out_name, rgbData.data(), W, H);
    }
    */

    if(is_fall) {
        std::cout << "[FallDetector] " << warning << std::endl;
    }

    // 7. Invoke Callback
    if (pImpl->callback) {
        VisionSDKEvent event;
        // event.timestamp = frame.timestamp; // NOT IN STRUCT
        event.frame_index = pImpl->frame_idx++; // Use and increment frame_idx
        event.is_fall_detected = is_fall;
        event.is_bed_exit = pImpl->is_bed_exit;
        // event.is_weak_movement = false; // NOT IN STRUCT
        event.is_strong = (pImpl->fall_consecutive_frames >= pImpl->config.fall_strong_threshold); // Heuristic
        event.confidence = (float)pImpl->fall_consecutive_frames / 10.0f; // Simplified
        if(event.confidence > 1.0f) event.confidence = 1.0f;
        
        // Face Info
        event.is_face = has_face;
        event.face_x = face_roi.x1;
        event.face_y = face_roi.y1;
        event.face_w = face_roi.x2 - face_roi.x1;
        event.face_h = face_roi.y2 - face_roi.y1;
        // event.face_score = face_roi.score; // NOT IN STRUCT

        pImpl->callback(event);
    }
    
    #if ENABLE_PERF_PROFILING
    long long t_logic_end = pImpl->get_now_us();
    pImpl->prof.fall_logic_time += (t_logic_end - t_logic_start);
    long long t_total_end = pImpl->get_now_us();
    pImpl->prof.total_time += (t_total_end - t0);
    
    pImpl->prof.frame_count++;
    if (pImpl->prof.frame_count >= 100) {
        double avg_total = (double)pImpl->prof.total_time / pImpl->prof.frame_count / 1000.0;
        double avg_me = (double)pImpl->prof.motion_est_time / pImpl->prof.frame_count / 1000.0;
        double avg_face = (double)pImpl->prof.face_detect_time / pImpl->prof.frame_count / 1000.0;
        double avg_logic = (double)pImpl->prof.fall_logic_time / pImpl->prof.frame_count / 1000.0;
        
        printf("[FallDetector Profiling] Avg Time (ms) - Total: %.2f, ME: %.2f, Face: %.2f, Logic: %.2f\n", 
               avg_total, avg_me, avg_face, avg_logic);
        
        pImpl->prof.Reset();
    }
    #endif

    return StatusCode::OK;
}

const std::vector<MotionObject>& FallDetector::GetMotionObjects() const {
    return pImpl->current_objects;
}

std::vector<std::pair<int, int>> FallDetector::GetBedRegion() const {
    return pImpl->bed_region;
}




std::vector<uint8_t> FallDetector::GetChangedBlocks() const {
    std::vector<uint8_t> ret;
    if(!pImpl) return ret;
    ret.reserve(pImpl->changed_mask.size());
    for(bool b : pImpl->changed_mask) ret.push_back(b ? 1 : 0);
    return ret;
}

std::vector<MotionVector> FallDetector::GetMotionVectors() const {
    if(!pImpl) return {};
    return pImpl->motion_vectors;
}

} // VisionSDK
